# coding: utf-8

"""
    OANDA v20 REST API

    The full OANDA v20 REST API Specification. This specification defines how to interact with v20 Accounts, Trades, Orders, Pricing and more. To authenticate use the string 'Bearer ' followed by the token which can be obtained at https://www.oanda.com/demo-account/tpa/personal_token  # noqa: E501

    OpenAPI spec version: 3.0.23
    Contact: api@oanda.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from oanda.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def cancel_order(self, account_id, order_specifier, **kwargs):  # noqa: E501
        """Cancel Order  # noqa: E501

        Cancel a pending Order in an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.cancel_order(account_id, order_specifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str order_specifier: The Order Specifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.cancel_order_with_http_info(account_id, order_specifier, **kwargs)  # noqa: E501
        else:
            (data) = self.cancel_order_with_http_info(account_id, order_specifier, **kwargs)  # noqa: E501
            return data

    def cancel_order_with_http_info(self, account_id, order_specifier, **kwargs):  # noqa: E501
        """Cancel Order  # noqa: E501

        Cancel a pending Order in an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.cancel_order_with_http_info(account_id, order_specifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str order_specifier: The Order Specifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'order_specifier', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `cancel_order`")  # noqa: E501
        # verify the required parameter 'order_specifier' is set
        if ('order_specifier' not in params or
                params['order_specifier'] is None):
            raise ValueError("Missing the required parameter `order_specifier` when calling `cancel_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501
        if 'order_specifier' in params:
            path_params['orderSpecifier'] = params['order_specifier']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/orders/{orderSpecifier}/cancel', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def close_position(self, account_id, instrument, close_position_body, **kwargs):  # noqa: E501
        """Close Position  # noqa: E501

        Closeout the open Position for a specific instrument in an Account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.close_position(account_id, instrument, close_position_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str instrument: Name of the Instrument (required)
        :param ClosePositionBody close_position_body: Representation of how to close the position (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.close_position_with_http_info(account_id, instrument, close_position_body, **kwargs)  # noqa: E501
        else:
            (data) = self.close_position_with_http_info(account_id, instrument, close_position_body, **kwargs)  # noqa: E501
            return data

    def close_position_with_http_info(self, account_id, instrument, close_position_body, **kwargs):  # noqa: E501
        """Close Position  # noqa: E501

        Closeout the open Position for a specific instrument in an Account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.close_position_with_http_info(account_id, instrument, close_position_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str instrument: Name of the Instrument (required)
        :param ClosePositionBody close_position_body: Representation of how to close the position (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'instrument', 'close_position_body', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method close_position" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `close_position`")  # noqa: E501
        # verify the required parameter 'instrument' is set
        if ('instrument' not in params or
                params['instrument'] is None):
            raise ValueError("Missing the required parameter `instrument` when calling `close_position`")  # noqa: E501
        # verify the required parameter 'close_position_body' is set
        if ('close_position_body' not in params or
                params['close_position_body'] is None):
            raise ValueError("Missing the required parameter `close_position_body` when calling `close_position`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501
        if 'instrument' in params:
            path_params['instrument'] = params['instrument']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'close_position_body' in params:
            body_params = params['close_position_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/positions/{instrument}/close', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def close_trade(self, account_id, trade_specifier, close_trade_body, **kwargs):  # noqa: E501
        """Close Trade  # noqa: E501

        Close (partially or fully) a specific open Trade in an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.close_trade(account_id, trade_specifier, close_trade_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str trade_specifier: Specifier for the Trade (required)
        :param CloseTradeBody close_trade_body: Details of how much of the open Trade to close. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.close_trade_with_http_info(account_id, trade_specifier, close_trade_body, **kwargs)  # noqa: E501
        else:
            (data) = self.close_trade_with_http_info(account_id, trade_specifier, close_trade_body, **kwargs)  # noqa: E501
            return data

    def close_trade_with_http_info(self, account_id, trade_specifier, close_trade_body, **kwargs):  # noqa: E501
        """Close Trade  # noqa: E501

        Close (partially or fully) a specific open Trade in an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.close_trade_with_http_info(account_id, trade_specifier, close_trade_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str trade_specifier: Specifier for the Trade (required)
        :param CloseTradeBody close_trade_body: Details of how much of the open Trade to close. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'trade_specifier', 'close_trade_body', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method close_trade" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `close_trade`")  # noqa: E501
        # verify the required parameter 'trade_specifier' is set
        if ('trade_specifier' not in params or
                params['trade_specifier'] is None):
            raise ValueError("Missing the required parameter `trade_specifier` when calling `close_trade`")  # noqa: E501
        # verify the required parameter 'close_trade_body' is set
        if ('close_trade_body' not in params or
                params['close_trade_body'] is None):
            raise ValueError("Missing the required parameter `close_trade_body` when calling `close_trade`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501
        if 'trade_specifier' in params:
            path_params['tradeSpecifier'] = params['trade_specifier']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'close_trade_body' in params:
            body_params = params['close_trade_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/trades/{tradeSpecifier}/close', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20026',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def configure_account(self, account_id, **kwargs):  # noqa: E501
        """Configure Account  # noqa: E501

        Set the client-configurable portions of an Account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.configure_account(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param ConfigureAccountBody configure_account_body: Representation of the Account configuration to set
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.configure_account_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.configure_account_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def configure_account_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Configure Account  # noqa: E501

        Set the client-configurable portions of an Account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.configure_account_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param ConfigureAccountBody configure_account_body: Representation of the Account configuration to set
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'accept_datetime_format', 'configure_account_body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method configure_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `configure_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'configure_account_body' in params:
            body_params = params['configure_account_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/configuration', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_order(self, account_id, create_order_body, **kwargs):  # noqa: E501
        """Create Order  # noqa: E501

        Create an Order for an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_order(account_id, create_order_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param CreateOrderBody create_order_body: (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse201
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_order_with_http_info(account_id, create_order_body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_order_with_http_info(account_id, create_order_body, **kwargs)  # noqa: E501
            return data

    def create_order_with_http_info(self, account_id, create_order_body, **kwargs):  # noqa: E501
        """Create Order  # noqa: E501

        Create an Order for an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_order_with_http_info(account_id, create_order_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param CreateOrderBody create_order_body: (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse201
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'create_order_body', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `create_order`")  # noqa: E501
        # verify the required parameter 'create_order_body' is set
        if ('create_order_body' not in params or
                params['create_order_body'] is None):
            raise ValueError("Missing the required parameter `create_order_body` when calling `create_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_order_body' in params:
            body_params = params['create_order_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/orders', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse201',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account(self, account_id, **kwargs):  # noqa: E501
        """Account Details  # noqa: E501

        Get the full details for a single Account that a client has access to. Full pending Order, open Trade and open Position representations are provided.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_account(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_account_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Account Details  # noqa: E501

        Get the full details for a single Account that a client has access to. Full pending Order, open Trade and open Position representations are provided.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_account_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_changes(self, account_id, **kwargs):  # noqa: E501
        """Poll Account Updates  # noqa: E501

        Endpoint used to poll an Account for its current state and changes since a specified TransactionID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_account_changes(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param str since_transaction_id: ID of the Transaction to get Account changes since.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_account_changes_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_changes_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_changes_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Poll Account Updates  # noqa: E501

        Endpoint used to poll an Account for its current state and changes since a specified TransactionID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_account_changes_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param str since_transaction_id: ID of the Transaction to get Account changes since.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'accept_datetime_format', 'since_transaction_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_changes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account_changes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []
        if 'since_transaction_id' in params:
            query_params.append(('sinceTransactionID', params['since_transaction_id']))  # noqa: E501

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/changes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_instruments(self, account_id, **kwargs):  # noqa: E501
        """Account Instruments  # noqa: E501

        Get the list of tradeable instruments for the given Account. The list of tradeable instruments is dependent on the regulatory division that the Account is located in, thus should be the same for all Accounts owned by a single user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_account_instruments(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param list[str] instruments: List of instruments to query specifically.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_account_instruments_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_instruments_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_instruments_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Account Instruments  # noqa: E501

        Get the list of tradeable instruments for the given Account. The list of tradeable instruments is dependent on the regulatory division that the Account is located in, thus should be the same for all Accounts owned by a single user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_account_instruments_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param list[str] instruments: List of instruments to query specifically.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'instruments']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_instruments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account_instruments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []
        if 'instruments' in params:
            query_params.append(('instruments', params['instruments']))  # noqa: E501
            collection_formats['instruments'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/instruments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_summary(self, account_id, **kwargs):  # noqa: E501
        """Account Summary  # noqa: E501

        Get a summary for a single Account that a client has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_account_summary(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_account_summary_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_summary_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_summary_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Account Summary  # noqa: E501

        Get a summary for a single Account that a client has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_account_summary_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_summary" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account_summary`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_external_user_info(self, user_specifier, **kwargs):  # noqa: E501
        """External User Info  # noqa: E501

        Fetch the externally-available user information for the specified user. This endpoint is intended to be used by 3rd parties that have been authorized by a user to view their personal information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_external_user_info(user_specifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str user_specifier: The User Specifier (required)
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_external_user_info_with_http_info(user_specifier, **kwargs)  # noqa: E501
        else:
            (data) = self.get_external_user_info_with_http_info(user_specifier, **kwargs)  # noqa: E501
            return data

    def get_external_user_info_with_http_info(self, user_specifier, **kwargs):  # noqa: E501
        """External User Info  # noqa: E501

        Fetch the externally-available user information for the specified user. This endpoint is intended to be used by 3rd parties that have been authorized by a user to view their personal information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_external_user_info_with_http_info(user_specifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str user_specifier: The User Specifier (required)
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_specifier']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_external_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_specifier' is set
        if ('user_specifier' not in params or
                params['user_specifier'] is None):
            raise ValueError("Missing the required parameter `user_specifier` when calling `get_external_user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_specifier' in params:
            path_params['userSpecifier'] = params['user_specifier']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userSpecifier}/externalInfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_instrument_candles(self, instrument, **kwargs):  # noqa: E501
        """Get Candlesticks  # noqa: E501

        Fetch candlestick data for an instrument.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_instrument_candles(instrument, async=True)
        >>> result = thread.get()

        :param async bool
        :param str instrument: Name of the Instrument (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param str price: The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).
        :param str granularity: The granularity of the candlesticks to fetch
        :param int count: The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return.
        :param str _from: The start of the time range to fetch candlesticks for.
        :param str to: The end of the time range to fetch candlesticks for.
        :param bool smooth: A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.
        :param bool include_first: A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.
        :param int daily_alignment: The hour of the day (in the specified timezone) to use for granularities that have daily alignments.
        :param str alignment_timezone: The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.
        :param str weekly_alignment: The day of the week used for granularities that have weekly alignment.
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_instrument_candles_with_http_info(instrument, **kwargs)  # noqa: E501
        else:
            (data) = self.get_instrument_candles_with_http_info(instrument, **kwargs)  # noqa: E501
            return data

    def get_instrument_candles_with_http_info(self, instrument, **kwargs):  # noqa: E501
        """Get Candlesticks  # noqa: E501

        Fetch candlestick data for an instrument.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_instrument_candles_with_http_info(instrument, async=True)
        >>> result = thread.get()

        :param async bool
        :param str instrument: Name of the Instrument (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param str price: The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).
        :param str granularity: The granularity of the candlesticks to fetch
        :param int count: The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return.
        :param str _from: The start of the time range to fetch candlesticks for.
        :param str to: The end of the time range to fetch candlesticks for.
        :param bool smooth: A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.
        :param bool include_first: A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.
        :param int daily_alignment: The hour of the day (in the specified timezone) to use for granularities that have daily alignments.
        :param str alignment_timezone: The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.
        :param str weekly_alignment: The day of the week used for granularities that have weekly alignment.
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['instrument', 'accept_datetime_format', 'price', 'granularity', 'count', '_from', 'to', 'smooth', 'include_first', 'daily_alignment', 'alignment_timezone', 'weekly_alignment']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_instrument_candles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'instrument' is set
        if ('instrument' not in params or
                params['instrument'] is None):
            raise ValueError("Missing the required parameter `instrument` when calling `get_instrument_candles`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'instrument' in params:
            path_params['instrument'] = params['instrument']  # noqa: E501

        query_params = []
        if 'price' in params:
            query_params.append(('price', params['price']))  # noqa: E501
        if 'granularity' in params:
            query_params.append(('granularity', params['granularity']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'smooth' in params:
            query_params.append(('smooth', params['smooth']))  # noqa: E501
        if 'include_first' in params:
            query_params.append(('includeFirst', params['include_first']))  # noqa: E501
        if 'daily_alignment' in params:
            query_params.append(('dailyAlignment', params['daily_alignment']))  # noqa: E501
        if 'alignment_timezone' in params:
            query_params.append(('alignmentTimezone', params['alignment_timezone']))  # noqa: E501
        if 'weekly_alignment' in params:
            query_params.append(('weeklyAlignment', params['weekly_alignment']))  # noqa: E501

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/instruments/{instrument}/candles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20029',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_order(self, account_id, order_specifier, **kwargs):  # noqa: E501
        """Get Order  # noqa: E501

        Get details for a single Order in an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_order(account_id, order_specifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str order_specifier: The Order Specifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_order_with_http_info(account_id, order_specifier, **kwargs)  # noqa: E501
        else:
            (data) = self.get_order_with_http_info(account_id, order_specifier, **kwargs)  # noqa: E501
            return data

    def get_order_with_http_info(self, account_id, order_specifier, **kwargs):  # noqa: E501
        """Get Order  # noqa: E501

        Get details for a single Order in an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_order_with_http_info(account_id, order_specifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str order_specifier: The Order Specifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'order_specifier', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_order`")  # noqa: E501
        # verify the required parameter 'order_specifier' is set
        if ('order_specifier' not in params or
                params['order_specifier'] is None):
            raise ValueError("Missing the required parameter `order_specifier` when calling `get_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501
        if 'order_specifier' in params:
            path_params['orderSpecifier'] = params['order_specifier']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/orders/{orderSpecifier}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_position(self, account_id, instrument, **kwargs):  # noqa: E501
        """Instrument Position  # noqa: E501

        Get the details of a single Instrument's Position in an Account. The Position may by open or not.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_position(account_id, instrument, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str instrument: Name of the Instrument (required)
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_position_with_http_info(account_id, instrument, **kwargs)  # noqa: E501
        else:
            (data) = self.get_position_with_http_info(account_id, instrument, **kwargs)  # noqa: E501
            return data

    def get_position_with_http_info(self, account_id, instrument, **kwargs):  # noqa: E501
        """Instrument Position  # noqa: E501

        Get the details of a single Instrument's Position in an Account. The Position may by open or not.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_position_with_http_info(account_id, instrument, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str instrument: Name of the Instrument (required)
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'instrument']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_position" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_position`")  # noqa: E501
        # verify the required parameter 'instrument' is set
        if ('instrument' not in params or
                params['instrument'] is None):
            raise ValueError("Missing the required parameter `instrument` when calling `get_position`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501
        if 'instrument' in params:
            path_params['instrument'] = params['instrument']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/positions/{instrument}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_prices(self, account_id, instruments, **kwargs):  # noqa: E501
        """Current Account Prices  # noqa: E501

        Get pricing information for a specified list of Instruments within an Account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_prices(account_id, instruments, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param list[str] instruments: List of Instruments to get pricing for. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param str since: Date/Time filter to apply to the response. Only prices and home conversions (if requested) with a time later than this filter (i.e. the price has changed after the since time) will be provided, and are filtered independently.
        :param bool include_units_available: Flag that enables the inclusion of the unitsAvailable field in the returned Price objects.
        :param bool include_home_conversions: Flag that enables the inclusion of the homeConversions field in the returned response. An entry will be returned for each currency in the set of all base and quote currencies present in the requested instruments list.
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_prices_with_http_info(account_id, instruments, **kwargs)  # noqa: E501
        else:
            (data) = self.get_prices_with_http_info(account_id, instruments, **kwargs)  # noqa: E501
            return data

    def get_prices_with_http_info(self, account_id, instruments, **kwargs):  # noqa: E501
        """Current Account Prices  # noqa: E501

        Get pricing information for a specified list of Instruments within an Account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_prices_with_http_info(account_id, instruments, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param list[str] instruments: List of Instruments to get pricing for. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param str since: Date/Time filter to apply to the response. Only prices and home conversions (if requested) with a time later than this filter (i.e. the price has changed after the since time) will be provided, and are filtered independently.
        :param bool include_units_available: Flag that enables the inclusion of the unitsAvailable field in the returned Price objects.
        :param bool include_home_conversions: Flag that enables the inclusion of the homeConversions field in the returned response. An entry will be returned for each currency in the set of all base and quote currencies present in the requested instruments list.
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'instruments', 'accept_datetime_format', 'since', 'include_units_available', 'include_home_conversions']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prices" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_prices`")  # noqa: E501
        # verify the required parameter 'instruments' is set
        if ('instruments' not in params or
                params['instruments'] is None):
            raise ValueError("Missing the required parameter `instruments` when calling `get_prices`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []
        if 'instruments' in params:
            query_params.append(('instruments', params['instruments']))  # noqa: E501
            collection_formats['instruments'] = 'csv'  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'include_units_available' in params:
            query_params.append(('includeUnitsAvailable', params['include_units_available']))  # noqa: E501
        if 'include_home_conversions' in params:
            query_params.append(('includeHomeConversions', params['include_home_conversions']))  # noqa: E501

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/pricing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_trade(self, account_id, trade_specifier, **kwargs):  # noqa: E501
        """Trade Details  # noqa: E501

        Get the details of a specific Trade in an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_trade(account_id, trade_specifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str trade_specifier: Specifier for the Trade (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_trade_with_http_info(account_id, trade_specifier, **kwargs)  # noqa: E501
        else:
            (data) = self.get_trade_with_http_info(account_id, trade_specifier, **kwargs)  # noqa: E501
            return data

    def get_trade_with_http_info(self, account_id, trade_specifier, **kwargs):  # noqa: E501
        """Trade Details  # noqa: E501

        Get the details of a specific Trade in an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_trade_with_http_info(account_id, trade_specifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str trade_specifier: Specifier for the Trade (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'trade_specifier', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_trade" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_trade`")  # noqa: E501
        # verify the required parameter 'trade_specifier' is set
        if ('trade_specifier' not in params or
                params['trade_specifier'] is None):
            raise ValueError("Missing the required parameter `trade_specifier` when calling `get_trade`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501
        if 'trade_specifier' in params:
            path_params['tradeSpecifier'] = params['trade_specifier']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/trades/{tradeSpecifier}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20025',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transaction(self, account_id, transaction_id, **kwargs):  # noqa: E501
        """Transaction Details  # noqa: E501

        Get the details of a single Account Transaction.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transaction(account_id, transaction_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str transaction_id: A Transaction ID (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_transaction_with_http_info(account_id, transaction_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transaction_with_http_info(account_id, transaction_id, **kwargs)  # noqa: E501
            return data

    def get_transaction_with_http_info(self, account_id, transaction_id, **kwargs):  # noqa: E501
        """Transaction Details  # noqa: E501

        Get the details of a single Account Transaction.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transaction_with_http_info(account_id, transaction_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str transaction_id: A Transaction ID (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'transaction_id', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_transaction`")  # noqa: E501
        # verify the required parameter 'transaction_id' is set
        if ('transaction_id' not in params or
                params['transaction_id'] is None):
            raise ValueError("Missing the required parameter `transaction_id` when calling `get_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501
        if 'transaction_id' in params:
            path_params['transactionID'] = params['transaction_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/transactions/{transactionID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transaction_range(self, account_id, _from, to, **kwargs):  # noqa: E501
        """Transaction ID Range  # noqa: E501

        Get a range of Transactions for an Account based on the Transaction IDs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transaction_range(account_id, _from, to, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str _from: The starting Transacion ID (inclusive) to fetch. (required)
        :param str to: The ending Transaction ID (inclusive) to fetch. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param list[str] type: The filter that restricts the types of Transactions to retreive.
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_transaction_range_with_http_info(account_id, _from, to, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transaction_range_with_http_info(account_id, _from, to, **kwargs)  # noqa: E501
            return data

    def get_transaction_range_with_http_info(self, account_id, _from, to, **kwargs):  # noqa: E501
        """Transaction ID Range  # noqa: E501

        Get a range of Transactions for an Account based on the Transaction IDs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transaction_range_with_http_info(account_id, _from, to, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str _from: The starting Transacion ID (inclusive) to fetch. (required)
        :param str to: The ending Transaction ID (inclusive) to fetch. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param list[str] type: The filter that restricts the types of Transactions to retreive.
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', '_from', 'to', 'accept_datetime_format', 'type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transaction_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_transaction_range`")  # noqa: E501
        # verify the required parameter '_from' is set
        if ('_from' not in params or
                params['_from'] is None):
            raise ValueError("Missing the required parameter `_from` when calling `get_transaction_range`")  # noqa: E501
        # verify the required parameter 'to' is set
        if ('to' not in params or
                params['to'] is None):
            raise ValueError("Missing the required parameter `to` when calling `get_transaction_range`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
            collection_formats['type'] = 'csv'  # noqa: E501

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/transactions/idrange', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transactions_since_id(self, account_id, id, **kwargs):  # noqa: E501
        """Transactions Since ID  # noqa: E501

        Get a range of Transactions for an Account starting at (but not including) a provided Transaction ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transactions_since_id(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str id: The ID of the last Transacion fetched. This query will return all Transactions newer than the TransactionID. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_transactions_since_id_with_http_info(account_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transactions_since_id_with_http_info(account_id, id, **kwargs)  # noqa: E501
            return data

    def get_transactions_since_id_with_http_info(self, account_id, id, **kwargs):  # noqa: E501
        """Transactions Since ID  # noqa: E501

        Get a range of Transactions for an Account starting at (but not including) a provided Transaction ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transactions_since_id_with_http_info(account_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str id: The ID of the last Transacion fetched. This query will return all Transactions newer than the TransactionID. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'id', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transactions_since_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_transactions_since_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_transactions_since_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/transactions/sinceid', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_info(self, user_specifier, **kwargs):  # noqa: E501
        """User Info  # noqa: E501

        Fetch the user information for the specified user. This endpoint is intended to be used by the user themself to obtain their own information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user_info(user_specifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str user_specifier: The User Specifier (required)
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_user_info_with_http_info(user_specifier, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_info_with_http_info(user_specifier, **kwargs)  # noqa: E501
            return data

    def get_user_info_with_http_info(self, user_specifier, **kwargs):  # noqa: E501
        """User Info  # noqa: E501

        Fetch the user information for the specified user. This endpoint is intended to be used by the user themself to obtain their own information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user_info_with_http_info(user_specifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str user_specifier: The User Specifier (required)
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_specifier']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_specifier' is set
        if ('user_specifier' not in params or
                params['user_specifier'] is None):
            raise ValueError("Missing the required parameter `user_specifier` when calling `get_user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_specifier' in params:
            path_params['userSpecifier'] = params['user_specifier']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userSpecifier}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20015',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def instruments_instrument_order_book_get(self, instrument, **kwargs):  # noqa: E501
        """Get Order Book  # noqa: E501

        Fetch an order book for an instrument.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.instruments_instrument_order_book_get(instrument, async=True)
        >>> result = thread.get()

        :param async bool
        :param str instrument: Name of the Instrument (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param str time: The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.instruments_instrument_order_book_get_with_http_info(instrument, **kwargs)  # noqa: E501
        else:
            (data) = self.instruments_instrument_order_book_get_with_http_info(instrument, **kwargs)  # noqa: E501
            return data

    def instruments_instrument_order_book_get_with_http_info(self, instrument, **kwargs):  # noqa: E501
        """Get Order Book  # noqa: E501

        Fetch an order book for an instrument.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.instruments_instrument_order_book_get_with_http_info(instrument, async=True)
        >>> result = thread.get()

        :param async bool
        :param str instrument: Name of the Instrument (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param str time: The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['instrument', 'accept_datetime_format', 'time']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method instruments_instrument_order_book_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'instrument' is set
        if ('instrument' not in params or
                params['instrument'] is None):
            raise ValueError("Missing the required parameter `instrument` when calling `instruments_instrument_order_book_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'instrument' in params:
            path_params['instrument'] = params['instrument']  # noqa: E501

        query_params = []
        if 'time' in params:
            query_params.append(('time', params['time']))  # noqa: E501

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/instruments/{instrument}/orderBook', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20030',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def instruments_instrument_position_book_get(self, instrument, **kwargs):  # noqa: E501
        """Get Position Book  # noqa: E501

        Fetch a position book for an instrument.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.instruments_instrument_position_book_get(instrument, async=True)
        >>> result = thread.get()

        :param async bool
        :param str instrument: Name of the Instrument (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param str time: The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.instruments_instrument_position_book_get_with_http_info(instrument, **kwargs)  # noqa: E501
        else:
            (data) = self.instruments_instrument_position_book_get_with_http_info(instrument, **kwargs)  # noqa: E501
            return data

    def instruments_instrument_position_book_get_with_http_info(self, instrument, **kwargs):  # noqa: E501
        """Get Position Book  # noqa: E501

        Fetch a position book for an instrument.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.instruments_instrument_position_book_get_with_http_info(instrument, async=True)
        >>> result = thread.get()

        :param async bool
        :param str instrument: Name of the Instrument (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param str time: The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['instrument', 'accept_datetime_format', 'time']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method instruments_instrument_position_book_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'instrument' is set
        if ('instrument' not in params or
                params['instrument'] is None):
            raise ValueError("Missing the required parameter `instrument` when calling `instruments_instrument_position_book_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'instrument' in params:
            path_params['instrument'] = params['instrument']  # noqa: E501

        query_params = []
        if 'time' in params:
            query_params.append(('time', params['time']))  # noqa: E501

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/instruments/{instrument}/positionBook', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20031',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_accounts(self, **kwargs):  # noqa: E501
        """List Accounts  # noqa: E501

        Get a list of all Accounts authorized for the provided token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_accounts(async=True)
        >>> result = thread.get()

        :param async bool
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_accounts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_accounts_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_accounts_with_http_info(self, **kwargs):  # noqa: E501
        """List Accounts  # noqa: E501

        Get a list of all Accounts authorized for the provided token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_accounts_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_accounts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_open_positions(self, account_id, **kwargs):  # noqa: E501
        """Open Positions  # noqa: E501

        List all open Positions for an Account. An open Position is a Position in an Account that currently has a Trade opened for it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_open_positions(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_open_positions_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_open_positions_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_open_positions_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Open Positions  # noqa: E501

        List all open Positions for an Account. An open Position is a Position in an Account that currently has a Trade opened for it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_open_positions_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_open_positions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `list_open_positions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/openPositions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_open_trades(self, account_id, **kwargs):  # noqa: E501
        """List Open Trades  # noqa: E501

        Get the list of open Trades for an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_open_trades(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_open_trades_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_open_trades_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_open_trades_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List Open Trades  # noqa: E501

        Get the list of open Trades for an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_open_trades_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_open_trades" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `list_open_trades`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/openTrades', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20024',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_orders(self, account_id, **kwargs):  # noqa: E501
        """List Orders  # noqa: E501

        Get a list of Orders for an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_orders(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param list[str] ids: List of Order IDs to retrieve
        :param str state: The state to filter the requested Orders by
        :param str instrument: The instrument to filter the requested orders by
        :param int count: The maximum number of Orders to return
        :param str before_id: The maximum Order ID to return. If not provided the most recent Orders in the Account are returned
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_orders_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_orders_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_orders_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List Orders  # noqa: E501

        Get a list of Orders for an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_orders_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param list[str] ids: List of Order IDs to retrieve
        :param str state: The state to filter the requested Orders by
        :param str instrument: The instrument to filter the requested orders by
        :param int count: The maximum number of Orders to return
        :param str before_id: The maximum Order ID to return. If not provided the most recent Orders in the Account are returned
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'accept_datetime_format', 'ids', 'state', 'instrument', 'count', 'before_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_orders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `list_orders`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
            collection_formats['ids'] = 'csv'  # noqa: E501
        if 'state' in params:
            query_params.append(('state', params['state']))  # noqa: E501
        if 'instrument' in params:
            query_params.append(('instrument', params['instrument']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'before_id' in params:
            query_params.append(('beforeID', params['before_id']))  # noqa: E501

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/orders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_pending_orders(self, account_id, **kwargs):  # noqa: E501
        """Pending Orders  # noqa: E501

        List all pending Orders in an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_pending_orders(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_pending_orders_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_pending_orders_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_pending_orders_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Pending Orders  # noqa: E501

        List all pending Orders in an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_pending_orders_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_pending_orders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `list_pending_orders`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/pendingOrders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_positions(self, account_id, **kwargs):  # noqa: E501
        """List Positions  # noqa: E501

        List all Positions for an Account. The Positions returned are for every instrument that has had a position during the lifetime of an the Account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_positions(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_positions_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_positions_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_positions_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List Positions  # noqa: E501

        List all Positions for an Account. The Positions returned are for every instrument that has had a position during the lifetime of an the Account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_positions_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_positions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `list_positions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/positions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_trades(self, account_id, **kwargs):  # noqa: E501
        """List Trades  # noqa: E501

        Get a list of Trades for an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_trades(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param list[str] ids: List of Trade IDs to retrieve.
        :param str state: The state to filter the requested Trades by.
        :param str instrument: The instrument to filter the requested Trades by.
        :param int count: The maximum number of Trades to return.
        :param str before_id: The maximum Trade ID to return. If not provided the most recent Trades in the Account are returned.
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_trades_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_trades_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_trades_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List Trades  # noqa: E501

        Get a list of Trades for an Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_trades_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param list[str] ids: List of Trade IDs to retrieve.
        :param str state: The state to filter the requested Trades by.
        :param str instrument: The instrument to filter the requested Trades by.
        :param int count: The maximum number of Trades to return.
        :param str before_id: The maximum Trade ID to return. If not provided the most recent Trades in the Account are returned.
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'accept_datetime_format', 'ids', 'state', 'instrument', 'count', 'before_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_trades" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `list_trades`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
            collection_formats['ids'] = 'csv'  # noqa: E501
        if 'state' in params:
            query_params.append(('state', params['state']))  # noqa: E501
        if 'instrument' in params:
            query_params.append(('instrument', params['instrument']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'before_id' in params:
            query_params.append(('beforeID', params['before_id']))  # noqa: E501

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/trades', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20023',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transactions(self, account_id, **kwargs):  # noqa: E501
        """List Transactions  # noqa: E501

        Get a list of Transactions pages that satisfy a time-based Transaction query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transactions(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param str _from: The starting time (inclusive) of the time range for the Transactions being queried.
        :param str to: The ending time (inclusive) of the time range for the Transactions being queried.
        :param int page_size: The number of Transactions to include in each page of the results.
        :param list[str] type: A filter for restricting the types of Transactions to retreive.
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_transactions_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_transactions_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_transactions_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List Transactions  # noqa: E501

        Get a list of Transactions pages that satisfy a time-based Transaction query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transactions_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param str _from: The starting time (inclusive) of the time range for the Transactions being queried.
        :param str to: The ending time (inclusive) of the time range for the Transactions being queried.
        :param int page_size: The number of Transactions to include in each page of the results.
        :param list[str] type: A filter for restricting the types of Transactions to retreive.
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'accept_datetime_format', '_from', 'to', 'page_size', 'type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transactions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `list_transactions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
            collection_formats['type'] = 'csv'  # noqa: E501

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/transactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_order(self, account_id, order_specifier, replace_order_body, **kwargs):  # noqa: E501
        """Replace Order  # noqa: E501

        Replace an Order in an Account by simultaneously cancelling it and creating a replacement Order  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.replace_order(account_id, order_specifier, replace_order_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str order_specifier: The Order Specifier (required)
        :param ReplaceOrderBody replace_order_body: Specification of the replacing Order. The replacing order must have the same type as the replaced Order. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse2011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.replace_order_with_http_info(account_id, order_specifier, replace_order_body, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_order_with_http_info(account_id, order_specifier, replace_order_body, **kwargs)  # noqa: E501
            return data

    def replace_order_with_http_info(self, account_id, order_specifier, replace_order_body, **kwargs):  # noqa: E501
        """Replace Order  # noqa: E501

        Replace an Order in an Account by simultaneously cancelling it and creating a replacement Order  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.replace_order_with_http_info(account_id, order_specifier, replace_order_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str order_specifier: The Order Specifier (required)
        :param ReplaceOrderBody replace_order_body: Specification of the replacing Order. The replacing order must have the same type as the replaced Order. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse2011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'order_specifier', 'replace_order_body', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `replace_order`")  # noqa: E501
        # verify the required parameter 'order_specifier' is set
        if ('order_specifier' not in params or
                params['order_specifier'] is None):
            raise ValueError("Missing the required parameter `order_specifier` when calling `replace_order`")  # noqa: E501
        # verify the required parameter 'replace_order_body' is set
        if ('replace_order_body' not in params or
                params['replace_order_body'] is None):
            raise ValueError("Missing the required parameter `replace_order_body` when calling `replace_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501
        if 'order_specifier' in params:
            path_params['orderSpecifier'] = params['order_specifier']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'replace_order_body' in params:
            body_params = params['replace_order_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/orders/{orderSpecifier}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2011',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_order_client_extensions(self, account_id, order_specifier, set_order_client_extensions_body, **kwargs):  # noqa: E501
        """Set Order Extensions  # noqa: E501

        Update the Client Extensions for an Order in an Account. Do not set, modify, or delete clientExtensions if your account is associated with MT4.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_order_client_extensions(account_id, order_specifier, set_order_client_extensions_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str order_specifier: The Order Specifier (required)
        :param SetOrderClientExtensionsBody set_order_client_extensions_body: Representation of the replacing Order (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_order_client_extensions_with_http_info(account_id, order_specifier, set_order_client_extensions_body, **kwargs)  # noqa: E501
        else:
            (data) = self.set_order_client_extensions_with_http_info(account_id, order_specifier, set_order_client_extensions_body, **kwargs)  # noqa: E501
            return data

    def set_order_client_extensions_with_http_info(self, account_id, order_specifier, set_order_client_extensions_body, **kwargs):  # noqa: E501
        """Set Order Extensions  # noqa: E501

        Update the Client Extensions for an Order in an Account. Do not set, modify, or delete clientExtensions if your account is associated with MT4.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_order_client_extensions_with_http_info(account_id, order_specifier, set_order_client_extensions_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str order_specifier: The Order Specifier (required)
        :param SetOrderClientExtensionsBody set_order_client_extensions_body: Representation of the replacing Order (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'order_specifier', 'set_order_client_extensions_body', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_order_client_extensions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `set_order_client_extensions`")  # noqa: E501
        # verify the required parameter 'order_specifier' is set
        if ('order_specifier' not in params or
                params['order_specifier'] is None):
            raise ValueError("Missing the required parameter `order_specifier` when calling `set_order_client_extensions`")  # noqa: E501
        # verify the required parameter 'set_order_client_extensions_body' is set
        if ('set_order_client_extensions_body' not in params or
                params['set_order_client_extensions_body'] is None):
            raise ValueError("Missing the required parameter `set_order_client_extensions_body` when calling `set_order_client_extensions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501
        if 'order_specifier' in params:
            path_params['orderSpecifier'] = params['order_specifier']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_order_client_extensions_body' in params:
            body_params = params['set_order_client_extensions_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/orders/{orderSpecifier}/clientExtensions', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_trade_client_extensions(self, account_id, trade_specifier, set_trade_client_extensions_body, **kwargs):  # noqa: E501
        """Set Trade Client Extensions  # noqa: E501

        Update the Client Extensions for a Trade. Do not add, update, or delete the Client Extensions if your account is associated with MT4.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_trade_client_extensions(account_id, trade_specifier, set_trade_client_extensions_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str trade_specifier: Specifier for the Trade (required)
        :param SetTradeClientExtensionsBody set_trade_client_extensions_body: Details of how to modify the Trade's Client Extensions. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_trade_client_extensions_with_http_info(account_id, trade_specifier, set_trade_client_extensions_body, **kwargs)  # noqa: E501
        else:
            (data) = self.set_trade_client_extensions_with_http_info(account_id, trade_specifier, set_trade_client_extensions_body, **kwargs)  # noqa: E501
            return data

    def set_trade_client_extensions_with_http_info(self, account_id, trade_specifier, set_trade_client_extensions_body, **kwargs):  # noqa: E501
        """Set Trade Client Extensions  # noqa: E501

        Update the Client Extensions for a Trade. Do not add, update, or delete the Client Extensions if your account is associated with MT4.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_trade_client_extensions_with_http_info(account_id, trade_specifier, set_trade_client_extensions_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str trade_specifier: Specifier for the Trade (required)
        :param SetTradeClientExtensionsBody set_trade_client_extensions_body: Details of how to modify the Trade's Client Extensions. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'trade_specifier', 'set_trade_client_extensions_body', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_trade_client_extensions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `set_trade_client_extensions`")  # noqa: E501
        # verify the required parameter 'trade_specifier' is set
        if ('trade_specifier' not in params or
                params['trade_specifier'] is None):
            raise ValueError("Missing the required parameter `trade_specifier` when calling `set_trade_client_extensions`")  # noqa: E501
        # verify the required parameter 'set_trade_client_extensions_body' is set
        if ('set_trade_client_extensions_body' not in params or
                params['set_trade_client_extensions_body'] is None):
            raise ValueError("Missing the required parameter `set_trade_client_extensions_body` when calling `set_trade_client_extensions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501
        if 'trade_specifier' in params:
            path_params['tradeSpecifier'] = params['trade_specifier']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_trade_client_extensions_body' in params:
            body_params = params['set_trade_client_extensions_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/trades/{tradeSpecifier}/clientExtensions', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20027',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_trade_dependent_orders(self, account_id, trade_specifier, set_trade_dependent_orders_body, **kwargs):  # noqa: E501
        """Set Dependent Orders  # noqa: E501

        Create, replace and cancel a Trade's dependent Orders (Take Profit, Stop Loss and Trailing Stop Loss) through the Trade itself  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_trade_dependent_orders(account_id, trade_specifier, set_trade_dependent_orders_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str trade_specifier: Specifier for the Trade (required)
        :param SetTradeDependentOrdersBody set_trade_dependent_orders_body: Details of how to modify the Trade's dependent Orders. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_trade_dependent_orders_with_http_info(account_id, trade_specifier, set_trade_dependent_orders_body, **kwargs)  # noqa: E501
        else:
            (data) = self.set_trade_dependent_orders_with_http_info(account_id, trade_specifier, set_trade_dependent_orders_body, **kwargs)  # noqa: E501
            return data

    def set_trade_dependent_orders_with_http_info(self, account_id, trade_specifier, set_trade_dependent_orders_body, **kwargs):  # noqa: E501
        """Set Dependent Orders  # noqa: E501

        Create, replace and cancel a Trade's dependent Orders (Take Profit, Stop Loss and Trailing Stop Loss) through the Trade itself  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_trade_dependent_orders_with_http_info(account_id, trade_specifier, set_trade_dependent_orders_body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param str trade_specifier: Specifier for the Trade (required)
        :param SetTradeDependentOrdersBody set_trade_dependent_orders_body: Details of how to modify the Trade's dependent Orders. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'trade_specifier', 'set_trade_dependent_orders_body', 'accept_datetime_format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_trade_dependent_orders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `set_trade_dependent_orders`")  # noqa: E501
        # verify the required parameter 'trade_specifier' is set
        if ('trade_specifier' not in params or
                params['trade_specifier'] is None):
            raise ValueError("Missing the required parameter `trade_specifier` when calling `set_trade_dependent_orders`")  # noqa: E501
        # verify the required parameter 'set_trade_dependent_orders_body' is set
        if ('set_trade_dependent_orders_body' not in params or
                params['set_trade_dependent_orders_body'] is None):
            raise ValueError("Missing the required parameter `set_trade_dependent_orders_body` when calling `set_trade_dependent_orders`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501
        if 'trade_specifier' in params:
            path_params['tradeSpecifier'] = params['trade_specifier']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_trade_dependent_orders_body' in params:
            body_params = params['set_trade_dependent_orders_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/trades/{tradeSpecifier}/orders', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20028',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stream_pricing(self, account_id, instruments, **kwargs):  # noqa: E501
        """Price Stream  # noqa: E501

        Get a stream of Account Prices starting from when the request is made. This pricing stream does not include every single price created for the Account, but instead will provide at most 4 prices per second (every 250 milliseconds) for each instrument being requested. If more than one price is created for an instrument during the 250 millisecond window, only the price in effect at the end of the window is sent. This means that during periods of rapid price movement, subscribers to this stream will not be sent every price. Pricing windows for different connections to the price stream are not all aligned in the same way (i.e. they are not all aligned to the top of the second). This means that during periods of rapid price movement, different subscribers may observe different prices depending on their alignment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stream_pricing(account_id, instruments, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param list[str] instruments: List of Instruments to stream Prices for. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param bool snapshot: Flag that enables/disables the sending of a pricing snapshot when initially connecting to the stream.
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.stream_pricing_with_http_info(account_id, instruments, **kwargs)  # noqa: E501
        else:
            (data) = self.stream_pricing_with_http_info(account_id, instruments, **kwargs)  # noqa: E501
            return data

    def stream_pricing_with_http_info(self, account_id, instruments, **kwargs):  # noqa: E501
        """Price Stream  # noqa: E501

        Get a stream of Account Prices starting from when the request is made. This pricing stream does not include every single price created for the Account, but instead will provide at most 4 prices per second (every 250 milliseconds) for each instrument being requested. If more than one price is created for an instrument during the 250 millisecond window, only the price in effect at the end of the window is sent. This means that during periods of rapid price movement, subscribers to this stream will not be sent every price. Pricing windows for different connections to the price stream are not all aligned in the same way (i.e. they are not all aligned to the top of the second). This means that during periods of rapid price movement, different subscribers may observe different prices depending on their alignment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stream_pricing_with_http_info(account_id, instruments, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :param list[str] instruments: List of Instruments to stream Prices for. (required)
        :param str accept_datetime_format: Format of DateTime fields in the request and response.
        :param bool snapshot: Flag that enables/disables the sending of a pricing snapshot when initially connecting to the stream.
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'instruments', 'accept_datetime_format', 'snapshot']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stream_pricing" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `stream_pricing`")  # noqa: E501
        # verify the required parameter 'instruments' is set
        if ('instruments' not in params or
                params['instruments'] is None):
            raise ValueError("Missing the required parameter `instruments` when calling `stream_pricing`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []
        if 'instruments' in params:
            query_params.append(('instruments', params['instruments']))  # noqa: E501
            collection_formats['instruments'] = 'csv'  # noqa: E501
        if 'snapshot' in params:
            query_params.append(('snapshot', params['snapshot']))  # noqa: E501

        header_params = {}
        if 'accept_datetime_format' in params:
            header_params['Accept-Datetime-Format'] = params['accept_datetime_format']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/pricing/stream', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20022',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stream_transactions(self, account_id, **kwargs):  # noqa: E501
        """Transaction Stream  # noqa: E501

        Get a stream of Transactions for an Account starting from when the request is made.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stream_transactions(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.stream_transactions_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.stream_transactions_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def stream_transactions_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Transaction Stream  # noqa: E501

        Get a stream of Transactions for an Account starting from when the request is made.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stream_transactions_with_http_info(account_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str account_id: Account Identifier (required)
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stream_transactions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `stream_transactions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['AccountID'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{AccountID}/transactions/stream', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20020',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
